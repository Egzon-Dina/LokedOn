#!/usr/bin/env node

/* globals cat, config, cp, ls, popd, pushd, pwd, rm, exec, exit, which */
/* eslint curly: 0 */
'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

require('colors');

require('shelljs/global');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

// do not die on errors
config.fatal = false;

//------------------------------------------------------------------------------
// constants
var repoRoot = pwd();
var packagePath = _path2['default'].join(repoRoot, 'package.json');
var changelog = _path2['default'].join(repoRoot, 'CHANGELOG.md');

var npmjson = JSON.parse(cat(packagePath));
var isPrivate = npmjson['private'];
var devDepsNode = npmjson.devDependencies;

//------------------------------------------------------------------------------
// check if one of 'rf-changelog' or 'mt-changelog' is used by project
var isCommitsChangelogUsed = devDepsNode && devDepsNode['rf-changelog'] || devDepsNode['mt-changelog'];
if (isCommitsChangelogUsed && !which('changelog')) {
  printErrorAndExit('The "[rf|mt]-changelog" package is present in "devDependencies", but it is not installed.');
}

var isWithinMtChangelog = npmjson.name === 'mt-changelog';
isCommitsChangelogUsed = isCommitsChangelogUsed || isWithinMtChangelog;

//------------------------------------------------------------------------------
// options
var configOptions = npmjson['release-script'] || {};
var bowerRoot = _path2['default'].join(repoRoot, configOptions.bowerRoot || 'amd/');
var tmpBowerRepo = _path2['default'].join(repoRoot, configOptions.tmpBowerRepo || 'tmp-bower-repo');
var bowerRepo = configOptions.bowerRepo; // if it is not set, then there is no bower repo

var githubToken = process.env.GITHUB_TOKEN;

var altPkgRootFolder = configOptions.altPkgRootFolder;

//------------------------------------------------------------------------------
// command line options
var yargsConf = _yargs2['default'].usage('Usage: $0 <version> [--preid <identifier>]').example('$0 minor --preid beta', 'Release with minor version bump with pre-release tag').example('$0 major', 'Release with major version bump').example('$0 major --notes "This is new cool version"', 'Add a custom message to release').example('$0 major --dry-run', 'Release dry run with patch version bump').example('$0 --preid beta', 'Release same version with pre-release bump').command('patch', 'Release patch').command('minor', 'Release minor').command('major', 'Release major').command('<version>', 'Release specific version').option('preid', {
  demand: false,
  describe: 'pre-release identifier',
  type: 'string'
}).option('dry-run', {
  alias: 'n',
  demand: false,
  'default': false,
  describe: 'Execute command in dry run mode. Will not commit, tag, push, or publish anything. Userful for testing.'
}).option('verbose', {
  demand: false,
  'default': false,
  describe: 'Increased debug output'
}).option('notes', {
  demand: false,
  'default': false,
  describe: 'A custom message for release. Overrides [rf|mt]changelog message'
});

var argv = yargsConf.argv;

if (argv.dryRun) console.log('DRY RUN'.magenta);

config.silent = !argv.verbose;

var versionBumpOptions = {
  type: argv._[0],
  preid: argv.preid
};

if (versionBumpOptions.type === undefined && versionBumpOptions.preid === undefined) {
  console.log('Must provide either a version bump type, preid (or both)'.red);
  console.log(yargsConf.help());
  exit(1);
}

var notesForRelease = argv.notes;

//------------------------------------------------------------------------------
// functions
function printErrorAndExit(error) {
  console.error(error.red);
  exit(1);
}

function run(command) {
  var _exec = exec(command);

  var code = _exec.code;
  var output = _exec.output;

  if (code !== 0) printErrorAndExit(output);
  return output;
}

function safeRun(command) {
  if (argv.dryRun) {
    console.log(('[' + command + ']').grey, 'DRY RUN'.magenta);
  } else {
    return run(command);
  }
}

/**
 * Npm's `package.json` 'repository.url' could be set to one of three forms:
 * git@github.com:<author>/<repo-name>.git
 * git+https://github.com/<author>/<repo-name>.git
 * or just <author>/<repo-name>
 * @returns [<author>, <repo-name>] array
 */
function getOwnerAndRepo(url) {
  var match = url.match(/^git@github\.com:(.*)\.git$/);
  match = match || url.match(/^git\+https:\/\/github\.com\/(.*)\.git$/);
  var gitUrlBase = match && match[1];
  return (gitUrlBase || url).split('/');
}

function release(_ref) {
  var type = _ref.type;
  var preid = _ref.preid;

  if (type === undefined && !preid) printErrorAndExit('Must specify version type or preid');

  // ensure git repo has no pending changes
  if (exec('git diff-index --name-only HEAD --').output.length) {
    printErrorAndExit('Git repository must be clean');
  }
  console.info('No pending changes'.cyan);

  // ensure git repo last version is fetched
  if (/\[behind (.*)\]/.test(exec('git fetch').output)) {
    printErrorAndExit('Your repo is behind by ' + RegExp.$1 + ' commits');
  }
  console.info('Current with latest changes from remote'.cyan);

  // check linting and tests
  console.log('Running: '.cyan + 'linting and tests'.green);
  run('npm run test');
  console.log('Completed: '.cyan + 'linting and tests'.green);

  // version bump
  var oldVersion = npmjson.version;
  var newVersion = undefined;

  if (type === undefined) {
    newVersion = oldVersion; // --preid
  } else if (['major', 'minor', 'patch'].indexOf(type) >= 0) {
      newVersion = _semver2['default'].inc(oldVersion, type);
    } else {
      newVersion = type; // '<version>', 'Release specific version'
    }

  if (preid) {
    newVersion = _semver2['default'].inc(newVersion, 'pre', preid);
  }

  npmjson.version = newVersion;
  (JSON.stringify(npmjson, null, 2) + '\n').to(packagePath);

  console.log('Version changed from '.cyan + oldVersion.green + ' to '.cyan + newVersion.green);
  safeRun('git add package.json');

  // npm run build
  if (npmjson.scripts.build) {
    console.log('Running: '.cyan + 'build'.green);
    var res = exec('npm run build');
    if (res.code !== 0) {
      // if error, then revert and exit
      console.log('Build failed, reverting version bump'.red);
      run('git reset HEAD .');
      run('git checkout package.json');
      console.log('Version bump reverted'.red);
      printErrorAndExit(res.output);
    }
    console.log('Completed: '.cyan + 'build'.green);
  } else {
    console.log('There is no "build" script in package.json. Skipping this step.'.yellow);
  }

  var vVersion = 'v' + newVersion;
  var versionAndNotes = notesForRelease = notesForRelease ? vVersion + ' ' + notesForRelease : vVersion;

  // generate changelog
  // within mt-changelog at this stage `./bin/changelog` is already built and tested
  var changelogCmd = isWithinMtChangelog ? './bin/changelog' : 'changelog';
  if (isCommitsChangelogUsed) {
    run(changelogCmd + ' --title="' + versionAndNotes + '" --out ' + changelog);
    safeRun('git add ' + changelog);
    console.log('Generated Changelog'.cyan);
  }

  safeRun('git commit -m "Release ' + vVersion + '"');

  // tag and release
  console.log('Tagging: '.cyan + vVersion.green);
  if (isCommitsChangelogUsed) {
    notesForRelease = run(changelogCmd + ' --title="' + versionAndNotes + '" -s');
    safeRun('changelog --title="' + versionAndNotes + '" -s | git tag -a -F - ' + vVersion);
  } else {
    safeRun('git tag -a --message="' + versionAndNotes + '" ' + vVersion);
  }
  safeRun('git push --follow-tags');
  console.log('Tagged: '.cyan + vVersion.green);

  // publish to GitHub
  if (githubToken) {
    console.log(('GitHub token found ' + githubToken).green);
    console.log('Publishing to GitHub: '.cyan + vVersion.green);

    if (argv.dryRun) {
      console.log('[publishing to GitHub]'.grey, 'DRY RUN'.magenta);
    } else {
      var _getOwnerAndRepo = getOwnerAndRepo(npmjson.repository.url || npmjson.repository);

      var _getOwnerAndRepo2 = _slicedToArray(_getOwnerAndRepo, 2);

      var githubOwner = _getOwnerAndRepo2[0];
      var githubRepo = _getOwnerAndRepo2[1];

      (0, _request2['default'])({
        uri: 'https://api.github.com/repos/' + githubOwner + '/' + githubRepo + '/releases',
        method: 'POST',
        json: true,
        body: {
          tag_name: vVersion, // eslint-disable-line camelcase
          name: githubRepo + ' ' + vVersion,
          body: notesForRelease,
          draft: false,
          prerelease: !!preid
        },
        headers: {
          'Authorization': 'token ' + githubToken,
          'User-Agent': 'release-script (https://github.com/alexkval/release-script)'
        }
      }, function (err, res, body) {
        if (err) {
          console.log('API request to GitHub, error has occured:'.red);
          console.log(err);
          console.log('Skip GitHub releasing'.yellow);
        } else if (res.statusMessage === 'Unauthorized') {
          console.log(('GitHub token ' + githubToken + ' is wrong').red);
          console.log('Skip GitHub releasing'.yellow);
        } else {
          console.log(('Published at ' + body.html_url).green);
        }
      });
    }
  }

  // npm
  if (isPrivate) {
    console.log('Package is private, skipping npm release'.yellow);
  } else {
    console.log('Releasing: '.cyan + 'npm package'.green);

    // publishing just /altPkgRootFolder content
    if (altPkgRootFolder) {
      // prepare custom `package.json` without `scripts` and `devDependencies`
      // because it already has been saved, we safely can use the same object
      delete npmjson.files; // because otherwise it would be wrong
      delete npmjson.scripts;
      delete npmjson.devDependencies;
      delete npmjson['release-script']; // this also doesn't belong to output
      var regexp = new RegExp(altPkgRootFolder + '\\/?');
      npmjson.main = npmjson.main.replace(regexp, ''); // remove folder part from path
      (JSON.stringify(npmjson, null, 2) + '\n').to(_path2['default'].join(altPkgRootFolder, 'package.json'));

      pushd(altPkgRootFolder);
      safeRun('npm publish');
      popd();
    } else {
      safeRun('npm publish');
    }

    console.log('Released: '.cyan + 'npm package'.green);
  }

  // bower
  if (isPrivate) {
    console.log('Package is private, skipping bower release'.yellow);
  } else if (bowerRepo) {
    console.log('Releasing: '.cyan + 'bower package'.green);
    rm('-rf', tmpBowerRepo);
    run('git clone ' + bowerRepo + ' ' + tmpBowerRepo);
    pushd(tmpBowerRepo);
    rm('-rf', ls(tmpBowerRepo).filter(function (file) {
      return file !== '.git';
    })); // delete all but `.git` dir
    cp('-R', bowerRoot, tmpBowerRepo);
    safeRun('git add -A .');
    safeRun('git commit -m "Release ' + vVersion + '"');
    safeRun('git tag -a --message=' + vVersion + ' ' + vVersion);
    safeRun('git push --follow-tags');
    popd();
    if (argv.dryRun) {
      console.log(('[rm -rf ' + tmpBowerRepo + ']').grey, 'DRY RUN'.magenta);
    } else {
      rm('-rf', tmpBowerRepo);
    }
    console.log('Released: '.cyan + 'bower package'.green);
  } else {
    console.log('The "bowerRepo" is not set in package.json. Not publishing bower.'.yellow);
  }

  console.log('Version '.cyan + ('v' + newVersion).green + ' released!'.cyan);
}

//------------------------------------------------------------------------------
//
release(versionBumpOptions);